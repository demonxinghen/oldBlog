<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>类加载器 | 我的博客</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">类加载器</h1><a id="logo" href="/.">我的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="查询"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">类加载器</h1><div class="post-meta"><a href="/2019/02/25/类加载器/#comments" class="comment-count"></a><p><span class="date">Feb 25, 2019</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>什么是类加载器？</p>
<p>类加载器就是负责读取Java字节代码，并转换成java.lang.Class类的一个实例。其本身也是一个类。</p>
<p>当一个Java项目启动的时候，JVM会找到main方法，根据对象之间的调用来对class文件和所引用的jar包中的class文件进行加载，方法区中开辟内存来存储类的运行时数据结构（包括静态变量、静态方法、常量池、类结构等），同时在堆中生成相应的Class对象指向方法区中对应的类运行时数据结构。</p>
<p>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。</p>
<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2.工作机制"></a>2.工作机制</h4><p>参考<a href="/2019/02/26/类加载工作机制/index.html">类加载工作机制</a>。</p>
<h4 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h4><p>（1）Bootstrap ClassLoader：引导类加载器，存放于&lt;JAVA_HOME&gt;\lib目录中，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）。用原生C++实现，无法被Java程序直接引用。</p>
<p>（2）Extension ClassLoader：扩展类加载器，存放于&lt;JAVA_HOME&gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。</p>
<p>（3）Application ClassLoader：应用类加载器，负责加载用户类路径上（ClassPath）所指定的类库，开发者可直接使用。</p>
<p>（4）Custom ClassLoader：自定义类加载器，开发人员通过继承java.lang.ClassLoader类来实现自己的加载器，以满足一些特殊的要求。</p>
<h4 id="4-双亲委派模型"><a href="#4-双亲委派模型" class="headerlink" title="4.双亲委派模型"></a>4.双亲委派模型</h4><p><img src="\img\blog\双亲委派模型.png" alt="双亲委派模型"></p>
<p>工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层引导类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（也就是没有找到这个类），子加载器才会尝试自己去加载。</p>
<p>好处：Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委托给引导类加载器去加载，因此在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序会变得一片混乱。</p>
<p>顶层的ClassLoader无法加载底层ClassLoader的类。解决方法也有，JDK中提供了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setContextClassLoader()</span><br></pre></td></tr></table></figure>
<p>用于解决顶层ClassLoader无法加载底层ClassLoader的类的问题，基本思想是在顶层的ClassLoader中，传入底层的ClassLoader的实例。</p>
<p>双亲委派模型的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否已经加载过</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	<span class="comment">//当前加载器存在父类加载器，递归调用父类加载器</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">//检查该类是否被Bootstrap加载器加载过，有则返回，否则返回null</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//既然父类加载器无法加载，则就是用用户自己所重载的类加载器</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        	<span class="comment">//链接link所加载的类。该方法名起得不好，有误导性</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-类加载的三个机制"><a href="#5-类加载的三个机制" class="headerlink" title="5.类加载的三个机制"></a>5.类加载的三个机制</h4><p>委托、可见性、单一性。<br>委托机制是指将加载一个类的请求交给父类加载器，如果父类加载器不能够找到或者加载这个类，那么再加载它。<br>可见性的原理是子类的加载器可以看见所有的父类加载器已经加载的类，而父类加载看不到子类加载器加载的类。<br>单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。</p>
<h4 id="6-Java虚拟机如何判定两个Class是相同的？"><a href="#6-Java虚拟机如何判定两个Class是相同的？" class="headerlink" title="6.Java虚拟机如何判定两个Class是相同的？"></a>6.Java虚拟机如何判定两个Class是相同的？</h4><p>JVM在判定两个class是否相同时，不仅要判断两个类名相同，还要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为两个class是相同的。这里的相同包括类的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字等判断出来的结果。</p>
<p>不同的类加载为相同名称的类创建了额外的名称空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间。这种技术在许多框架中都被用到，例如OGSI、Web容器（Tomcat），破坏了双亲模式。</p>
<p>OGSI的ClassLoader形成网状结构，根据需要自由加载Class。</p>
<p>Tomcat的WebappClassLoader就会先加载自己的Class，找不到再委托parent。</p>
<p>对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>
<h4 id="7-tips"><a href="#7-tips" class="headerlink" title="7.tips"></a>7.tips</h4><h5 id="7-1可不可以自己写个String类？"><a href="#7-1可不可以自己写个String类？" class="headerlink" title="7.1可不可以自己写个String类？"></a>7.1可不可以自己写个String类？</h5><p>不可以，因为根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了。（应该自己写的String类也要求是java.lang.String，这时候子类加载器会发现父类加载器已经加载过String类。）</p>
<h5 id="7-2能否在加载类的时候，对类的字节码进行修改？"><a href="#7-2能否在加载类的时候，对类的字节码进行修改？" class="headerlink" title="7.2能否在加载类的时候，对类的字节码进行修改？"></a>7.2能否在加载类的时候，对类的字节码进行修改？</h5><p>可以，使用Java探针技术。</p>
</div><div class="tags"><a href="/tags/JVM/">JVM</a><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2019/02/26/类加载工作机制/" class="pre">类加载工作机制</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概述"><span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-工作机制"><span class="toc-text">2.工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-类加载器"><span class="toc-text">3.类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-双亲委派模型"><span class="toc-text">4.双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-类加载的三个机制"><span class="toc-text">5.类加载的三个机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java虚拟机如何判定两个Class是相同的？"><span class="toc-text">6.Java虚拟机如何判定两个Class是相同的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-tips"><span class="toc-text">7.tips</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1可不可以自己写个String类？"><span class="toc-text">7.1可不可以自己写个String类？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2能否在加载类的时候，对类的字节码进行修改？"><span class="toc-text">7.2能否在加载类的时候，对类的字节码进行修改？</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/图解ConcurrentHashMap/">图解ConcurrentHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/图解HashMap(二)/">图解HashMap(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/图解HashMap(一)/">图解HashMap(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/18/数据结构-链表/">数据结构--链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/G1垃圾收集器/">G1垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/CMS垃圾收集器/">CMS垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/HotSpot垃圾收集器/">HotSpot垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/垃圾回收算法/">垃圾回收算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/Excel小技巧/">Excel小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/PowerShell/">PowerShell</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日常/">日常</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/日常/" style="font-size: 15px;">日常</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="null" title="待定1" target="_blank">待定1</a><ul></ul><a href="null" title="待定2" target="_blank">待定2</a><ul></ul><a href="null" title="待定3" target="_blank">待定3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><span><a rel="nofollow" target="_blank" href="https://demonxinghen.github.io"> 个人博客</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="/js/MathJax-2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><div id="script" type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></div><div id="script" type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></div></body></html>