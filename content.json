[{"title":"G1垃圾收集器","date":"2019-03-13T12:47:14.000Z","path":"2019/03/13/G1垃圾收集器/","text":"G1是一款面向服务端应用的垃圾收集器。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。 之前介绍的几组垃圾收集器组合，都有几个共同点： 年轻代、老年代是独立且连续的内存块； 年轻代收集使用单Eden、双survivor进行复制算法； 老年代收集必须扫描整个老年代区域； 都是以尽可能少而快的执行GC为设计原则。 开启参数：-XX:+UseG1GC","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"CMS垃圾收集器","date":"2019-03-13T12:47:02.000Z","path":"2019/03/13/CMS垃圾收集器/","text":"CMS垃圾收集器（Concurrent Mark Sweep）,CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。 特点针对老年代，基于“标记-清除”算法(不进行压缩操作，产生内存碎片)，以获取最短回收停顿时间为目标，并发收集、低停顿，HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 应用场景与用户交互较多的场景，希望系统停顿时间最短，注重服务的响应速度，以给用户带来较好的体验，如常见WEB、B/S系统的服务器上的应用。 运作过程 初始标记：仅标记一下GC Roots能直接关联到的对象，速度很快，但需要“Stop The World”。多线程执行。 并发标记：进行GC Roots Tracing的过程，刚才产生的集合中标记出存活对象，应用程序也在运行，并不能保证可以标记出所有的存活对象。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，需要“Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短，采用多线程并行执行来提升效率。 并发清除：回收所有的垃圾对象。 整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作，所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行。 CMS收集器运行示意图如下： 缺点 对CPU资源非常敏感 并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。 CMS的默认收集线程数量是=(CPU数量+3)/4； 当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。 无法处理浮动垃圾 在并发清除时，用户线程新产生的垃圾，称为浮动垃圾。这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集，也可以认为CMS所需要的空间比其他垃圾收集器大。 -XX:CMSInitiatingOccupancyFraction：设置CMS预留内存空间，JDK1.5默认值为68%，JDK1.6变为大约92%。 可能出现“Concurrent Mode Failure”失败 如果CMS预留内存空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生，这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。 产生大量内存碎片 由于CMS基于“标记-清除”算法，清除后不进行压缩操作。 解决方法： 1.-XX:+UseCMSCompactAtFullCollection，使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程，但合并整理过程无法并发，停顿时间会变长，默认开启（但不会进行，结合下面的CMSFullGCsBeforeCompaction）。 2.-XX:+CMSFullGCsBeforeCompaction，设置执行多少次不压缩的Full GC后，来一次压缩整理，为减少合并整理过程的停顿时间。默认为0，也就是说每次都执行Full GC，不会进行压缩整理，由于空间不再连续，CMS需要使用可用“空闲列表”内存分配方式，这比简单实用“碰撞指针”分配内存消耗大。 总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间，但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"HotSpot垃圾收集器","date":"2019-03-13T12:10:13.000Z","path":"2019/03/13/HotSpot垃圾收集器/","text":"上图展示了7种收集器，白色区域为新生代收集器，灰色区域为老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用。 Serial收集器 Serial收集器是一个新生代收集器，单线程收集器，使用复制算法，单线程指不仅仅只会使用一个CPU或者一条收集线程去完成垃圾收集，更重要的是它在进行垃圾收集时，必须暂停其他所有线程的工作。（Stop-the-world） Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。其优点：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器减少了线程交互的开销。 所以运行在Client模式下的虚拟机来说是一个不错的选择。 缺点：JVM在后台自动发起和自动完成的，把用户正常的工作线程全部停掉，即GC停顿，会带给用户不良的体验。 ParNew 收集器 Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样；实现上，也共用了相当多的代码。但是它确实许多运行在Server模式下虚拟机中首选的新生代收集器，其中一个与性能无关的原因就是除了Serial收集器外，目前只有ParNew收集器能与CMS收集器配合工作。 ParNew 收集器也是使用 -XX:+UseConcMarkSeepGC选项后的默认新生代收集器，也可以使用-XX:UseParNewGC选项来强制指定;ParaNew在单cpu的环境绝对不会比Serial收集效果好,在多线程环境下更适用于ParaNew，默认开启的垃圾收集器线程数就是CPU数，可通过-XX：parallelGCThreads参数来限制收集器线程数 Parallel Scavenge收集器 Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。就是CPU用于运行用户代码时间与CPU总消耗时间比值，即吞吐量=运行用户代码时间/(用户代码时间+GC时间)。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是最大垃圾收集时间-XX:MaxGCPauseMillis和直接设置吞吐量大小-XX:GCTimeRatio。 MaxGCPauseMillis允许设置一个大于0的毫秒数，收集器尽可能的保证GC时间不超过此设定值，注意千万不要认为把这个参数设置的小就能让系统收集速度变快，GC停顿时间缩短是以减少吞吐量的代价和新生代空间的代价来换取的。也就是这个值越小，新生代空间也会越小，也就会导致垃圾收集更加频繁。 GCTimeRatio参数值允许设置为一个大于0小于100的整数，也是GC时间的占比数，例如 -XX:GCTimeRatio=19，GC时间占比=(1/19+1)即5%，默认为99即1%。 Scavenge收集器还提供一个参数-XX:+UseAdaptiveSizePolicy 。这是一个开关参数，当使用这个参数时就不需要知道新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数，虚拟机会根据系统运行性能监控信息，动态调整这些参数以提供最合适的GC时间或者最大吞吐量，这种GC自适应的调节策略(GC Ergonomics)也是和ParNew很大的区别。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Serial Old 收集器 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。主要两大用途： （1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 （2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法，在JDK1.6才开始提供的。在此之前，Parallel Scavenge 一直处于一个很尴尬的状态，如果新生代选择了Paralle Scavenge，老年代只能选择Serial Old，因为CMS无法于Parallel Scavenge配合工作，由于Serial Old的服务端性能上的欠缺，就算使用Paraller Scavenge在吞吐量上还是没有PraNew+CMS组合高。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合(Paraller Scavenge + Parallel Old)。 应用场景：在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器 设置参数： “-XX:+UseParallelOldGC”：指定使用Parallel Old收集器。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"垃圾回收算法","date":"2019-03-13T11:30:47.000Z","path":"2019/03/13/垃圾回收算法/","text":"判断对象是否存活1.引用计数法 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，引用失效时，引用就减1。任何时刻计数器为0的对象就是不可能再被使用的对象，此时该对象为可回收对象。 优点： 实现简单，判定效率高。 缺点： 无法解决对象之间相互循环引用的问题。 123456789101112131415161718public class CountTest&#123; public Object instance = null; private static final int _1MB = 1024*1024; private byte[] bigSize = new byte[2*_1MB]; public static void main(String[] args)&#123; CountTest count1 = new CountTest(); CountTest count2 = new CountTest(); count1.instance = count2; count2.instance = count1; count1 = null; count2 = null; System.gc(); &#125;&#125; 实际上这两个对象已经不可能再被引用，但是因为它们之间相互引用，导致它们的计数器都不为0，因此GC无法回收它们。 2.可达性分析法 该算法的基本思想是通过一系列的成为“GC roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（reference chain），当一个对象到GC roots没有任何引用链相连时，则证明此对象是不可用的。 在Java语言中，可作为GC roots的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即native方法）引用的对象。 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时它处于“缓刑”阶段，要正真宣告一个对象“死亡”，至少要经历两次标记过程。如果对象在经历可达性分析后发现没有与GC roots的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，则虚拟机将这两种情况视为“没有必要执行”。 如果该对象被判定为有必要执行finalize()方法，那么这个对象将会被放到一个叫做F-Queue的队列中，并在稍后在一个由虚拟机自动建立的低优先级的Finalizer线程负责运行，但是虚拟机并不“承诺”会等待它执行结束。finalize()方法是对象逃脱死亡命运的最后一次机会。意思就是重写finalize()方法，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。但是只能自救一次，因为finalize()方法只会被系统调用一次。 垃圾回收算法标记清除算法（Mark-Sweep）首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 缺点： 效率低下，标记和清除两个过程效率都相对较低； 标记清除之后会产生大量不连续的内存碎片，内存碎片太多可能会导致以后在程序需要创建较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法（Copying）将可用内存按容量划分为大小相等的两块，每次只是用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后把用过的内存空间一次性清理掉。 优点：每次都是对整个内存半区进行垃圾回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效； 缺点：内存利用率低，这种算法的代价是将内存缩小为了原来的一半，代价太大。 标记整理算法（Mark-Compact）标记整理算法，标记过程与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法（Generation Collection）根据对象存活周期的不同，将内存划分为几块。一般把java堆划分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的算法。 在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就采用复制法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中对象存活率高，没有额外空间对它进行分配担保，就必须采用“标记-清除”算法或“标记-整理”算法来进行回收。 增量算法（待补充）如果一次性将所有垃圾进行处理，需要系统长时间的停顿，那么就让垃圾回收的线程和应用程序的线程交替执行。垃圾回收只是回收一小块内存，接着切换到应用程序线程。这样就减少了系统的停顿时间。因为线程的切换和上下文的转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降。增量收集算法的技术是标记清除和整理，只是允许垃圾回收进程以阶段完成标记、清理、或复制工作。 RC Immix算法（待补充）","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Excel小技巧","date":"2019-03-12T12:50:14.000Z","path":"2019/03/12/Excel小技巧/","text":"1.复制多行 A B C 1111 1111 2222 1111 3333 2222 2222 3333 3333 如何将列A变成列C那样，每行数据重复N次。 在列3输入公式 =INDEX(A:A,ROW(A2)/2)。 A:A，指的是取A的数据，如果是E列，就E:E。 ROW(A2)/2是重复两次，如果是要重复N次，就ROW(AN)/N。原理没了解，大概是取模吧。 2.长度补足 A B C 1 00001 2 00002 3 00003 4 00004 如何将列A变成列C那样，每行数据都保持N位数，长度不足用0补齐。 在列C输入公式 =REPT(0,5-LEN(A2))&amp;A2 0：指的是需要重复的文本 5：是你需要的固定长度 REPT(0,5-LEN(A2))就是假设单元格A2文本长度为X，那么就补齐5-X的0，最后&amp;A2就是将之前A2的数据拼到后面。","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"PowerShell","date":"2019-03-12T12:40:14.000Z","path":"2019/03/12/PowerShell/","text":"1.字符串查找 在当前目录查找指定字符串，不递归查询（即不查子文件夹） select-string -path 路径\\* -pattern “字符串” 例如查询D:\\hexo\\source_posts目录下包含“666”的文件 select-string -path D:\\hexo\\source_posts\\* -pattern “666” 如果只查询txt文件 select-string -path D:\\hexo\\source_posts\\*.txt -pattern “666” 如果当前目录有子文件夹，可能会报错，不用管，是因为访问不了子文件夹。 在当前目录查找指定字符串，递归查询（即所有子文件夹也要查询） get-childitem -path 路径 -recurse | select-string -pattern “字符串” -allmatches 参数 -recurse 递归查询 -allmatches 匹配所有，取消该参数，只匹配每个文件第一个符合的地方 get-childitem -path D:\\hexo\\source_posts -recurse | select-string -pattern “666” -allmatches","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"JVM局部变量表","date":"2019-03-12T11:47:14.000Z","path":"2019/03/12/JVM局部变量表/","text":"","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"MySql慢日志查询","date":"2019-03-07T11:30:14.000Z","path":"2019/03/07/MySql慢日志查询/","text":"","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库基本概念","date":"2019-03-06T14:30:14.000Z","path":"2019/03/06/数据库基本概念/","text":"本文以MySql的InnoDB引擎为例。 数据库基本概念InnoDB存储引擎结构与Oracle大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页有时也被称为块（block）。 对于InnoDB而言，其数据文件最小的存储单位为页。默认为16KB大小。InnoDB存储引擎对于空间的申请不是每次以16KB的方式申请，而是以区的方式。一个区的大小为1MB，总共有64个页。这样的目的是提高空间的申请效率。如果数据是按照减值顺序存放的，那么读取这些页，将在一个连续的地址中，这样可以避免磁头的大量的寻址时间。 行行对应的是表中的行记录，每页存储最多的行记录也是有硬性规定的，最多16KB/2-200，即7992行（16KB是页大小） 页1.数据库I/O的基本单位，16KB，存储引擎的最小管理单位 2.就是MySql的聚簇索引的叶子节点 3.物理上64个连续的页可以连成一个区 4.数据页、Undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页 5.从InnoDB 1.2.x版本开始，可以利用innodb_page_size来改变页size，但是改变只能在初始化InnoDB实例前进行修改，之后便无法进行修改，除非mysqldump导出创建新库 区1.按区分配存储空间 2.区是InnoDB存储引擎访问的最小单位 3.区是InnoDB寻找存储空间的最小单位 4.一个区由64个连续的页组成，大小为1MB，为保证区中页的连续性，InnoDB会一次从磁盘中申请4~5个区 5.新建表的时候，空表的默认大小为96KB,是由于为了高效的利用磁盘空间，在开始插入数据时表会先利用32个页大小的碎片页来存储数据，当这些碎片使用完后，表大小才会按照MB倍数来增加 段1.每个用户至少有两个段 2.在MySql中，数据是按照B+树来存储，因此数据即索引，因此数据段是B+树的叶子节点，索引段是B+树的非叶子节点 3.回滚段即rollback segment，管理undo log segment，用于存储undo日志，用于事务失败后数据回滚以及在事务未提交之前通过undo日志获取之前版本的数据，在InnoDB1.1版本之前一个InnoDB,只支持一个回滚段，支持1023个并发修改事务同时进行，在InnoDB1.2版本，将回滚段数量提高到了128个，也就是说可以同时进行128*1023个并发修改事务。 表空间1.表空间是InnoDB存储引擎结构的最高层，所有的数据都存放在表空间中。 2.默认只有一个表空间ibdata1（系统表空间，只能扩大不能缩小） 3.默认使用共享表空间存储方式 4.单独表空间存储方式，开启独立表空间的参数：innodb_file_per_table=1，此时每个表的数据以一个单独的文件来存放 表碎片及表空间碎片的判断及清除临时表空间","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"索引工作原理","date":"2019-03-04T11:30:14.000Z","path":"2019/03/04/索引工作原理/","text":"聚簇索引每个InnoDB的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。为了能够获得高性能的查询、插入和其他数据库操作，理解InnoDB聚簇索引是很有必要的。 聚簇索引按照如下规则创建： 当定义了主键后，InnoDB会利用主键来生成其聚簇索引； 如果没有主键，InnoDB会选择一个非空的唯一索引来创建聚簇索引； 如果这也没有，InnoDB会隐式的创建一个自增的列来作为聚簇索引。 聚簇索引整体是一个b+树，非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页，这就决定了表中的数据也是聚簇索引中的一部分，数据页之间是通过一个双向链表来链接的，B+树是一棵平衡查找树，也就是聚簇索引的数据存储是有序的，但是这个是逻辑上的有序，事实上物理存储可以隔很远，因为数据页之间是通过双向链表来连接，假如物理存储是顺序的话，那维护聚簇索引的成本非常的高。 辅助索引除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引。 通过辅助索引来查找对应的行记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（不用查询聚簇索引）。 创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引。 辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的IO操作。 创建索引的原则最左原则参考资料：《高性能 MySQL 第三版》","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据结构---B+树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---B+树/","text":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构---B-树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---B-树/","text":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构---二叉树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---二叉树/","text":"1.概述二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树(left subtree)”和“右子树(right subtree)”。二叉树常被用于二叉查找树和二叉堆。 2.分类 满二叉树：一棵深度为k，且有$2^k$-1个结点的二叉树。特点是每一层上的结点数都是最大结点树。 完全二叉树：除最后一层外，其余层都是满的，最后一层或者是满的，或者是右边缺少连续若干结点。 平衡二叉树：又被称为AVL树，是一棵二叉排序树，且具有以下性质：它是一棵空树，或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。 3.定义及性质二叉树是递归定义的，逻辑上二叉树有五种基本形态。 (1)空二叉树——如图(a)；(2)只有一个根结点的二叉树——如图(b)；(3)只有左子树——如图(c)；(4)只有右子树——如图(d)；(5)完全二叉树——如图(e)。 4.遍历遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。 设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况： DLR（称为先根次序遍历） LDR（称为中根次序遍历） LRD （称为后根次序遍历） 层次遍历 即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低） 5.与树的区别二叉树和树有许多相似之处，但二叉树不是树。 树中结点的最大度数没有限制，而二叉树结点的最大度数为2。 树的结点没有左右之分，而二叉树的结点有左右之分。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"JVM内存模型","date":"2019-02-27T12:30:14.000Z","path":"2019/02/27/JVM内存模型/","text":"也被合称为运行时数据区。 程序计数器（PC Register）最小的一块内存区域，记录了当前线程执行的字节码的行号，在虚拟机模型里，字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等都要依赖程序计数器完成。 这是JVM规范中唯一一个没有规定会导致OOM的区域。 虚拟机栈（JVM Stack）每个方法被执行的时候都会创建一个“栈帧”，用于存储局部变量表（包括参数）、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。生命周期与线程相同，是线程私有的。使用一段连续的内存空间。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。 栈帧组成： 局部变量表（Local Variable Table）：是被组织为一个字长（32bit）为单位、从0开始计数的数组，用于存放方法参数和局部变量。存放了编译器可知的各种基本数据类型、对象引用（引用指针，非对象本身），其中64位长度的long和double类型的变量会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配（在方法的Code属性的max_locals数据项中确定），当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。 操作数栈：也是被组织为一个字长（32bit）为单位的数组。但和局部变量表不一样的是它不是通过索引来访问，而是通过标准的栈操作（压栈和出栈）来访问的。可理解为Java虚拟机栈中的一个用于计算的临时数据存储区。 动态连接：指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 方法返回：一个方法被执行后，有两种方式退出该方法。 1).执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定。该方式被称为正常完成出口（Normal Method Invocation Completion）。 2).方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。无论是Java虚拟机内部产生的异常，还是代码中使用throw字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。这种方式被称为异常完成出口（Aburt Method Invocation Completion）。不会给它的调用者产生任何返回值。 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息。这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回和附加信息归为一类，称为栈帧信息。 本地方法栈（Native Stack）类似虚拟机栈，区别在于虚拟机栈是为虚拟机执行的Java方法服务，而本地方法栈是为Native方法服务。 方法区（Method Area）也称为“永久代（Permanent Generation）”，用于存储虚拟机加载的类信息、常量（jdk7开始移到堆内存中）、静态变量，是线程共享的区域。 jdk8取消了方法区这个概念，取而代之的是元空间（Metaspace）。 运行时常量池（Runtime Constant Pool）方法区的一部分。用于存放编译器生成的各种字面量和符号引用。并非预置入Class文件中常量池的内容才进入常量池，运行期间页可能将新的常量放入池中，这种特性被开发人员利用的比较多的是String类的intern()方法。 堆（Heap）是Java虚拟机所管理内存中最大的一块内存区域，该区域存放了对象实例和数组（但不是所有的对象实例都在堆中，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配，也有可能还是在堆内存中分配。），生命周期与虚拟机相同。 在垃圾回收的时候，往往将堆内存分为新生代和老年代（大小比例为1：2），新生代又由Eden和Survivor0，Survivor1（也有称为from Survivor,to Survivor的）组成，三者的比例是8：1：1。新生代一般采用的是复制算法，老年代采用的是标记整理算法。 堆、方法区、运行时常量池为线程共享，程序计数器、本地方法栈、虚拟机栈为线程私有。 为什么要分开设计堆栈？ 栈存储了处理逻辑，堆存储了具体的数据，这样隔离设计更为清晰。 堆栈分离，使得堆可以被多个栈共享。 栈保存了上下文的信息，因此只能向上增长；而堆是动态分配。 直接内存 直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"类加载工作机制","date":"2019-02-26T11:00:15.000Z","path":"2019/02/26/类加载工作机制/","text":"Java源码编译由三个过程组成：源码编译机制、类加载机制、类执行机制。 类的生命周期：加载(Loading)–验证(Verification)–准备(Preparation)–解析(Resolution)–初始化(Initialization)–使用(Using)–卸载(Unloading)。其中从加载到初始化五个阶段属于类加载的部分，验证–准备–解析三个阶段又合称为连接。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 1系统可能在第一次使用某个类时加载该类，也可能采用预加载机制来加载某个类。 1.加载在加载阶段(可以参考java.lang.ClassLoader的loadClass()方法)，虚拟机主要完成三件事：1.1通过一个类的全限定名来获取定义此类的二进制字节流(并没有指明要从Class文件获取，也可以通过其他渠道，譬如：网络、动态生成、数据库等)1.2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。1.3在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 2.验证验证的主要目的是判断class文件的合法性，比如class文件一定是以0xCAFEBABE开头的，另外对版本号也会做验证，例如使用jdk1.8编译的class文件在jdk1.6虚拟机上运行，因为版本问题就会验证不通过。除此之外还会对元数据、字节码进行验证，具体的验证过程略过。 3.准备这个阶段正式为类变量（static修饰的变量）分配内存并设置初始值，这个内存分配是发生在方法区中。3.1这里并没有对实例变量进行内存分配，实例变量会在对象实例化时随着对象一起分配在Java堆中。3.2这里的初始值，是指数据类型的零值。 12private static int a = 3;这个类变量a是在准备阶段设置为0，在初始化阶段将3赋值给变量a。 但是如果是static final的变量，在准备阶段就会赋值。 12private static final int b = 1;这段代码在准备阶段就会将1赋值给变量b。 4.解析解析过程就是讲符号引用替换为直接引用。 注：符号引用就是一个Java源文件在被编译时，在不清楚被引用类实际内存地址的情况下，会使用唯一识别并定位到目标的符号来代替。如A类引用了B类，编译时A并不知道B类实际的内存地址，故可以使用能唯一识别B的符号来代替。而当类加载时，编译后的class文件实际已被调入内存，可知道A、B的实际内存地址，当引用的目标已被加载入内存，则此时的引用为直接引用。 5.初始化初始化是类加载的最后一步，这个时候才开始执行类中定义的Java程序代码。在这个阶段最重要的事情就是对类变量进行初始化，关注的重点是父子类之间各类资源初始化的顺序。Java中对类变量指定初始值有两种方式：1.声明类变量时指定初始值。2.使用静态初始化块为类变量指定初始值。初始化的时机3.1创建类实例的时候，分别有： 12345a.使用new关键字创建实例。b.通过反射创建实例。c.通过反序列化方式创建实例。 3.2调用某个类的类方法（静态方法）3.3访问某个类或接口的类变量，或为该类变量赋值。3.4初始化某个类的子类。当初始化子类的时候，该子类的所有父类都会被初始化。3.5直接使用java.exe命令来运行某个主类。 除了上面几种方式会自动初始化一个类，其他访问类的方式都称不会触发类的初始化，称为被动引用。如 12a.子类引用父类的静态变量，不会导致子类初始化。b.通过数组定义引用类，不会触发此类的初始化。 123456789101112131415161718public class SupClass&#123; public static int a = 123; static &#123; System.out.println(\"supclass init\"); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; SupClass[] spc = new SupClass[10]; &#125;&#125;// 控制台不会有输出。 1c.引用常量时，不会触发此类的初始化。因为用final修饰的类变量，在编译时就已经确定好放入常量池了，访问该类变量时，等于直接从常量池中获取，并没有初始化该类。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"类加载器","date":"2019-02-25T11:30:14.000Z","path":"2019/02/25/类加载器/","text":"1.概述什么是类加载器？ 类加载器就是负责读取Java字节代码，并转换成java.lang.Class类的一个实例。其本身也是一个类。 当一个Java项目启动的时候，JVM会找到main方法，根据对象之间的调用来对class文件和所引用的jar包中的class文件进行加载，方法区中开辟内存来存储类的运行时数据结构（包括静态变量、静态方法、常量池、类结构等），同时在堆中生成相应的Class对象指向方法区中对应的类运行时数据结构。 Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 2.工作机制参考类加载工作机制。 3.类加载器（1）Bootstrap ClassLoader：引导类加载器，存放于&lt;JAVA_HOME&gt;\\lib目录中，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）。用原生C++实现，无法被Java程序直接引用。 （2）Extension ClassLoader：扩展类加载器，存放于&lt;JAVA_HOME&gt;\\lib\\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。 （3）Application ClassLoader：应用类加载器，负责加载用户类路径上（ClassPath）所指定的类库，开发者可直接使用。 （4）Custom ClassLoader：自定义类加载器，开发人员通过继承java.lang.ClassLoader类来实现自己的加载器，以满足一些特殊的要求。 4.双亲委派模型 工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层引导类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（也就是没有找到这个类），子加载器才会尝试自己去加载。 好处：Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委托给引导类加载器去加载，因此在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序会变得一片混乱。 顶层的ClassLoader无法加载底层ClassLoader的类。解决方法也有，JDK中提供了一个方法： 1Thread.setContextClassLoader() 用于解决顶层ClassLoader无法加载底层ClassLoader的类的问题，基本思想是在顶层的ClassLoader中，传入底层的ClassLoader的实例。 双亲委派模型的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 1. 检查是否已经加载过 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //当前加载器存在父类加载器，递归调用父类加载器 c = parent.loadClass(name, false); &#125; else &#123; //检查该类是否被Bootstrap加载器加载过，有则返回，否则返回null c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //既然父类加载器无法加载，则就是用用户自己所重载的类加载器 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //链接link所加载的类。该方法名起得不好，有误导性 resolveClass(c); &#125; return c; &#125;&#125; 5.类加载的三个机制委托、可见性、单一性。委托机制是指将加载一个类的请求交给父类加载器，如果父类加载器不能够找到或者加载这个类，那么再加载它。可见性的原理是子类的加载器可以看见所有的父类加载器已经加载的类，而父类加载看不到子类加载器加载的类。单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。 6.Java虚拟机如何判定两个Class是相同的？JVM在判定两个class是否相同时，不仅要判断两个类名相同，还要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为两个class是相同的。这里的相同包括类的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字等判断出来的结果。 不同的类加载为相同名称的类创建了额外的名称空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间。这种技术在许多框架中都被用到，例如OGSI、Web容器（Tomcat），破坏了双亲模式。 OGSI的ClassLoader形成网状结构，根据需要自由加载Class。 Tomcat的WebappClassLoader就会先加载自己的Class，找不到再委托parent。 对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。 7.tips7.1可不可以自己写个String类？不可以，因为根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了。（应该自己写的String类也要求是java.lang.String，这时候子类加载器会发现父类加载器已经加载过String类。） 7.2能否在加载类的时候，对类的字节码进行修改？可以，使用Java探针技术。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]