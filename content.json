[{"title":"Excel小技巧","date":"2019-03-12T12:50:14.000Z","path":"2019/03/12/Excel小技巧/","text":"1.复制多行 A B C 1111 1111 2222 1111 3333 2222 2222 3333 3333 如何将列A变成列C那样，每行数据重复N次。 在列3输入公式 =INDEX(A:A,ROW(A2)/2)。 A:A，指的是取A的数据，如果是E列，就E:E。 ROW(A2)/2是重复两次，如果是要重复N次，就ROW(AN)/N。原理没了解，大概是取模吧。 2.长度补足 A B C 1 00001 2 00002 3 00003 4 00004 如何将列A变成列C那样，每行数据都保持N位数，长度不足用0补齐。 在列C输入公式 =REPT(0,5-LEN(A2))&amp;A2 0：指的是需要重复的文本 5：是你需要的固定长度 REPT(0,5-LEN(A2))就是假设单元格A2文本长度为X，那么就补齐5-X的0，最后&amp;A2就是将之前A2的数据拼到后面。","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"PowerShell","date":"2019-03-12T12:40:14.000Z","path":"2019/03/12/PowerShell/","text":"1.字符串查找 在当前目录查找指定字符串，不递归查询（即不查子文件夹） select-string -path 路径\\* -pattern “字符串” 例如查询D:\\hexo\\source_posts目录下包含“666”的文件 select-string -path D:\\hexo\\source_posts\\* -pattern “666” 如果只查询txt文件 select-string -path D:\\hexo\\source_posts\\*.txt -pattern “666” 如果当前目录有子文件夹，可能会报错，不用管，是因为访问不了子文件夹。 在当前目录查找指定字符串，递归查询（即所有子文件夹也要查询） get-childitem -path 路径 -recurse | select-string -pattern “字符串” -allmatches 参数 -recurse 递归查询 -allmatches 匹配所有，取消该参数，只匹配每个文件第一个符合的地方 get-childitem -path D:\\hexo\\source_posts -recurse | select-string -pattern “666” -allmatches","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"JVM局部变量表","date":"2019-03-12T11:47:14.000Z","path":"2019/03/12/JVM局部变量表/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"MySql慢日志查询","date":"2019-03-07T11:30:14.000Z","path":"2019/03/07/MySql慢日志查询/","text":"","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库基本概念","date":"2019-03-06T14:30:14.000Z","path":"2019/03/06/数据库基本概念/","text":"本文以MySql的InnoDB引擎为例。 数据库基本概念InnoDB存储引擎结构与Oracle大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页有时也被称为块（block）。 对于InnoDB而言，其数据文件最小的存储单位为页。默认为16KB大小。InnoDB存储引擎对于空间的申请不是每次以16KB的方式申请，而是以区的方式。一个区的大小为1MB，总共有64个页。这样的目的是提高空间的申请效率。如果数据是按照减值顺序存放的，那么读取这些页，将在一个连续的地址中，这样可以避免磁头的大量的寻址时间。 行行对应的是表中的行记录，每页存储最多的行记录也是有硬性规定的，最多16KB/2-200，即7992行（16KB是页大小） 页1.数据库I/O的基本单位，16KB，存储引擎的最小管理单位 2.就是MySql的聚簇索引的叶子节点 3.物理上64个连续的页可以连成一个区 4.数据页、Undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页 5.从InnoDB 1.2.x版本开始，可以利用innodb_page_size来改变页size，但是改变只能在初始化InnoDB实例前进行修改，之后便无法进行修改，除非mysqldump导出创建新库 区1.按区分配存储空间 2.区是InnoDB存储引擎访问的最小单位 3.区是InnoDB寻找存储空间的最小单位 4.一个区由64个连续的页组成，大小为1MB，为保证区中页的连续性，InnoDB会一次从磁盘中申请4~5个区 5.新建表的时候，空表的默认大小为96KB,是由于为了高效的利用磁盘空间，在开始插入数据时表会先利用32个页大小的碎片页来存储数据，当这些碎片使用完后，表大小才会按照MB倍数来增加 段1.每个用户至少有两个段 2.在MySql中，数据是按照B+树来存储，因此数据即索引，因此数据段是B+树的叶子节点，索引段是B+树的非叶子节点 3.回滚段即rollback segment，管理undo log segment，用于存储undo日志，用于事务失败后数据回滚以及在事务未提交之前通过undo日志获取之前版本的数据，在InnoDB1.1版本之前一个InnoDB,只支持一个回滚段，支持1023个并发修改事务同时进行，在InnoDB1.2版本，将回滚段数量提高到了128个，也就是说可以同时进行128*1023个并发修改事务。 表空间1.表空间是InnoDB存储引擎结构的最高层，所有的数据都存放在表空间中。 2.默认只有一个表空间ibdata1（系统表空间，只能扩大不能缩小） 3.默认使用共享表空间存储方式 4.单独表空间存储方式，开启独立表空间的参数：innodb_file_per_table=1，此时每个表的数据以一个单独的文件来存放 表碎片及表空间碎片的判断及清除临时表空间","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"索引工作原理","date":"2019-03-04T11:30:14.000Z","path":"2019/03/04/索引工作原理/","text":"聚簇索引每个InnoDB的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。为了能够获得高性能的查询、插入和其他数据库操作，理解InnoDB聚簇索引是很有必要的。 聚簇索引按照如下规则创建： 当定义了主键后，InnoDB会利用主键来生成其聚簇索引； 如果没有主键，InnoDB会选择一个非空的唯一索引来创建聚簇索引； 如果这也没有，InnoDB会隐式的创建一个自增的列来作为聚簇索引。 聚簇索引整体是一个b+树，非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页，这就决定了表中的数据也是聚簇索引中的一部分，数据页之间是通过一个双向链表来链接的，B+树是一棵平衡查找树，也就是聚簇索引的数据存储是有序的，但是这个是逻辑上的有序，事实上物理存储可以隔很远，因为数据页之间是通过双向链表来连接，假如物理存储是顺序的话，那维护聚簇索引的成本非常的高。 辅助索引除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引。 通过辅助索引来查找对应的行记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（不用查询聚簇索引）。 创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引。 辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的IO操作。 创建索引的原则最左原则参考资料：《高性能 MySQL 第三版》","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据结构---二叉树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---二叉树/","text":"1.概述二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树(left subtree)”和“右子树(right subtree)”。二叉树常被用于二叉查找树和二叉堆。 2.分类 满二叉树：一棵深度为k，且有$2^k$-1个结点的二叉树。特点是每一层上的结点数都是最大结点树。 完全二叉树：除最后一层外，其余层都是满的，最后一层或者是满的，或者是右边缺少连续若干结点。 平衡二叉树：又被称为AVL树，是一棵二叉排序树，且具有以下性质：它是一棵空树，或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。 3.定义及性质二叉树是递归定义的，逻辑上二叉树有五种基本形态。 (1)空二叉树——如图(a)；(2)只有一个根结点的二叉树——如图(b)；(3)只有左子树——如图(c)；(4)只有右子树——如图(d)；(5)完全二叉树——如图(e)。 4.遍历遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。 设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况： DLR（称为先根次序遍历） LDR（称为中根次序遍历） LRD （称为后根次序遍历） 层次遍历 即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低） 5.与树的区别二叉树和树有许多相似之处，但二叉树不是树。 树中结点的最大度数没有限制，而二叉树结点的最大度数为2。 树的结点没有左右之分，而二叉树的结点有左右之分。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构---B-树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---B-树/","text":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构---B+树","date":"2019-03-03T11:30:14.000Z","path":"2019/03/03/数据结构---B+树/","text":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"JVM内存模型","date":"2019-02-27T12:30:14.000Z","path":"2019/02/27/JVM内存模型/","text":"也被合称为运行时数据区。 程序计数器（PC Register）最小的一块内存区域，记录了当前线程执行的字节码的行号，在虚拟机模型里，字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等都要依赖程序计数器完成。 这是JVM规范中唯一一个没有规定会导致OOM的区域。 虚拟机栈（JVM Stack）每个方法被执行的时候都会创建一个“栈帧”，用于存储局部变量表（包括参数）、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。生命周期与线程相同，是线程私有的。使用一段连续的内存空间。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。 栈帧组成： 局部变量表（Local Variable Table）：是被组织为一个字长（32bit）为单位、从0开始计数的数组，用于存放方法参数和局部变量。存放了编译器可知的各种基本数据类型、对象引用（引用指针，非对象本身），其中64位长度的long和double类型的变量会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配（在方法的Code属性的max_locals数据项中确定），当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。 操作数栈：也是被组织为一个字长（32bit）为单位的数组。但和局部变量表不一样的是它不是通过索引来访问，而是通过标准的栈操作（压栈和出栈）来访问的。可理解为Java虚拟机栈中的一个用于计算的临时数据存储区。 动态连接：指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 方法返回：一个方法被执行后，有两种方式退出该方法。 1).执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定。该方式被称为正常完成出口（Normal Method Invocation Completion）。 2).方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。无论是Java虚拟机内部产生的异常，还是代码中使用throw字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。这种方式被称为异常完成出口（Aburt Method Invocation Completion）。不会给它的调用者产生任何返回值。 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息。这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回和附加信息归为一类，称为栈帧信息。 本地方法栈（Native Stack）类似虚拟机栈，区别在于虚拟机栈是为虚拟机执行的Java方法服务，而本地方法栈是为Native方法服务。 方法区（Method Area）也称为“永久代（Permanent Generation）”，用于存储虚拟机加载的类信息、常量（jdk7开始移到堆内存中）、静态变量，是线程共享的区域。 jdk8取消了方法区这个概念，取而代之的是元空间（Metaspace）。 运行时常量池（Runtime Constant Pool）方法区的一部分。用于存放编译器生成的各种字面量和符号引用。并非预置入Class文件中常量池的内容才进入常量池，运行期间页可能将新的常量放入池中，这种特性被开发人员利用的比较多的是String类的intern()方法。 堆（Heap）是Java虚拟机所管理内存中最大的一块内存区域，该区域存放了对象实例和数组（但不是所有的对象实例都在堆中，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配，也有可能还是在堆内存中分配。），生命周期与虚拟机相同。 在垃圾回收的时候，往往将堆内存分为新生代和老年代（大小比例为1：2），新生代又由Eden和Survivor0，Survivor1（也有称为from Survivor,to Survivor的）组成，三者的比例是8：1：1。新生代一般采用的是复制算法，老年代采用的是标记整理算法。 堆、方法区、运行时常量池为线程共享，程序计数器、本地方法栈、虚拟机栈为线程私有。 为什么要分开设计堆栈？ 栈存储了处理逻辑，堆存储了具体的数据，这样隔离设计更为清晰。 堆栈分离，使得堆可以被多个栈共享。 栈保存了上下文的信息，因此只能向上增长；而堆是动态分配。 直接内存 直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"类加载工作机制","date":"2019-02-26T11:00:15.000Z","path":"2019/02/26/类加载工作机制/","text":"Java源码编译由三个过程组成：源码编译机制、类加载机制、类执行机制。 类的生命周期：加载(Loading)–验证(Verification)–准备(Preparation)–解析(Resolution)–初始化(Initialization)–使用(Using)–卸载(Unloading)。其中从加载到初始化五个阶段属于类加载的部分，验证–准备–解析三个阶段又合称为连接。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 1系统可能在第一次使用某个类时加载该类，也可能采用预加载机制来加载某个类。 1.加载在加载阶段(可以参考java.lang.ClassLoader的loadClass()方法)，虚拟机主要完成三件事：1.1通过一个类的全限定名来获取定义此类的二进制字节流(并没有指明要从Class文件获取，也可以通过其他渠道，譬如：网络、动态生成、数据库等)1.2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。1.3在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 2.验证验证的主要目的是判断class文件的合法性，比如class文件一定是以0xCAFEBABE开头的，另外对版本号也会做验证，例如使用jdk1.8编译的class文件在jdk1.6虚拟机上运行，因为版本问题就会验证不通过。除此之外还会对元数据、字节码进行验证，具体的验证过程略过。 3.准备这个阶段正式为类变量（static修饰的变量）分配内存并设置初始值，这个内存分配是发生在方法区中。3.1这里并没有对实例变量进行内存分配，实例变量会在对象实例化时随着对象一起分配在Java堆中。3.2这里的初始值，是指数据类型的零值。 12private static int a = 3;这个类变量a是在准备阶段设置为0，在初始化阶段将3赋值给变量a。 但是如果是static final的变量，在准备阶段就会赋值。 12private static final int b = 1;这段代码在准备阶段就会将1赋值给变量b。 4.解析解析过程就是讲符号引用替换为直接引用。 注：符号引用就是一个Java源文件在被编译时，在不清楚被引用类实际内存地址的情况下，会使用唯一识别并定位到目标的符号来代替。如A类引用了B类，编译时A并不知道B类实际的内存地址，故可以使用能唯一识别B的符号来代替。而当类加载时，编译后的class文件实际已被调入内存，可知道A、B的实际内存地址，当引用的目标已被加载入内存，则此时的引用为直接引用。 5.初始化初始化是类加载的最后一步，这个时候才开始执行类中定义的Java程序代码。在这个阶段最重要的事情就是对类变量进行初始化，关注的重点是父子类之间各类资源初始化的顺序。Java中对类变量指定初始值有两种方式：1.声明类变量时指定初始值。2.使用静态初始化块为类变量指定初始值。初始化的时机3.1创建类实例的时候，分别有： 12345a.使用new关键字创建实例。b.通过反射创建实例。c.通过反序列化方式创建实例。 3.2调用某个类的类方法（静态方法）3.3访问某个类或接口的类变量，或为该类变量赋值。3.4初始化某个类的子类。当初始化子类的时候，该子类的所有父类都会被初始化。3.5直接使用java.exe命令来运行某个主类。 除了上面几种方式会自动初始化一个类，其他访问类的方式都称不会触发类的初始化，称为被动引用。如 12a.子类引用父类的静态变量，不会导致子类初始化。b.通过数组定义引用类，不会触发此类的初始化。 123456789101112131415161718public class SupClass&#123; public static int a = 123; static &#123; System.out.println(\"supclass init\"); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; SupClass[] spc = new SupClass[10]; &#125;&#125;// 控制台不会有输出。 1c.引用常量时，不会触发此类的初始化。因为用final修饰的类变量，在编译时就已经确定好放入常量池了，访问该类变量时，等于直接从常量池中获取，并没有初始化该类。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"类加载器","date":"2019-02-25T11:30:14.000Z","path":"2019/02/25/类加载器/","text":"1.概述什么是类加载器？ 类加载器就是负责读取Java字节代码，并转换成java.lang.Class类的一个实例。其本身也是一个类。 当一个Java项目启动的时候，JVM会找到main方法，根据对象之间的调用来对class文件和所引用的jar包中的class文件进行加载，方法区中开辟内存来存储类的运行时数据结构（包括静态变量、静态方法、常量池、类结构等），同时在堆中生成相应的Class对象指向方法区中对应的类运行时数据结构。 Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 2.工作机制参考类加载工作机制。 3.类加载器（1）Bootstrap ClassLoader：引导类加载器，存放于&lt;JAVA_HOME&gt;\\lib目录中，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）。用原生C++实现，无法被Java程序直接引用。 （2）Extension ClassLoader：扩展类加载器，存放于&lt;JAVA_HOME&gt;\\lib\\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。 （3）Application ClassLoader：应用类加载器，负责加载用户类路径上（ClassPath）所指定的类库，开发者可直接使用。 （4）Custom ClassLoader：自定义类加载器，开发人员通过继承java.lang.ClassLoader类来实现自己的加载器，以满足一些特殊的要求。 4.双亲委派模型 工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层引导类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（也就是没有找到这个类），子加载器才会尝试自己去加载。 好处：Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委托给引导类加载器去加载，因此在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序会变得一片混乱。 顶层的ClassLoader无法加载底层ClassLoader的类。解决方法也有，JDK中提供了一个方法： 1Thread.setContextClassLoader() 用于解决顶层ClassLoader无法加载底层ClassLoader的类的问题，基本思想是在顶层的ClassLoader中，传入底层的ClassLoader的实例。 双亲委派模型的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 1. 检查是否已经加载过 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //当前加载器存在父类加载器，递归调用父类加载器 c = parent.loadClass(name, false); &#125; else &#123; //检查该类是否被Bootstrap加载器加载过，有则返回，否则返回null c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //既然父类加载器无法加载，则就是用用户自己所重载的类加载器 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //链接link所加载的类。该方法名起得不好，有误导性 resolveClass(c); &#125; return c; &#125;&#125; 5.类加载的三个机制委托、可见性、单一性。委托机制是指将加载一个类的请求交给父类加载器，如果父类加载器不能够找到或者加载这个类，那么再加载它。可见性的原理是子类的加载器可以看见所有的父类加载器已经加载的类，而父类加载看不到子类加载器加载的类。单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。 6.Java虚拟机如何判定两个Class是相同的？JVM在判定两个class是否相同时，不仅要判断两个类名相同，还要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为两个class是相同的。这里的相同包括类的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字等判断出来的结果。 不同的类加载为相同名称的类创建了额外的名称空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间。这种技术在许多框架中都被用到，例如OGSI、Web容器（Tomcat），破坏了双亲模式。 OGSI的ClassLoader形成网状结构，根据需要自由加载Class。 Tomcat的WebappClassLoader就会先加载自己的Class，找不到再委托parent。 对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。 7.tips7.1可不可以自己写个String类？不可以，因为根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了。（应该自己写的String类也要求是java.lang.String，这时候子类加载器会发现父类加载器已经加载过String类。） 7.2能否在加载类的时候，对类的字节码进行修改？可以，使用Java探针技术。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]